#light

namespace Jurassic.RayTracer

open System.Drawing
open Microsoft.FSharp.Math
open Jurassic.RayTracer
open Materials
open Misc


[<AbstractClass>]
type SceneElement() = 
    let mutable center = vector [0.0; 0.0; 0.0; 1.0]
    let mutable rotation = Matrix.identity 4
    let mutable scale = 1.0
    let mutable scaleX = 1.0
    let mutable scaleY = 1.0
    let mutable scaleZ = 1.0
    let mutable colorSurface = uniform (fromColor Color.White)
    let mutable emissiveSurface = uniform (fromColor Color.Black)
    let mutable reflectivitySurface = uniform 0.0
    let mutable specExpSurface = uniform 42.0
    let mutable specularitySurface = uniform 0.7
    let mutable translucencySurface = uniform 0.0
    let mutable transform = Matrix.identity 4
    let mutable transformInverse = Matrix.inverse transform
    
    member private this.updateTransform() = 
        this.Transform <- Matrix.translation(center) * rotation * 
                          (Matrix.scaling (scale * scaleX) (scale * scaleY) (scale * scaleZ))
    
    member this.Center with get() = center
                       and  set v = center <- v
                                    this.updateTransform()
    
    
    member this.Scale with get() = scale
                      and  set v = scale <- v
                                   this.updateTransform()
    
    ///The final scaling amount in the direction of the x axis will be
    ///Scale * ScaleX
    member this.ScaleX with get() = scaleX
                        and  set v = scaleX <- v
                                     this.updateTransform()
    
    ///The final scaling amount in the direction of the y axis will be
    ///Scale * ScaleY
    member this.ScaleY with get() = scaleY
                        and  set v = scaleY <- v
                                     this.updateTransform()
    
    ///The final scaling amount in the direction of the z axis will be
    ///Scale * ScaleZ
    member this.ScaleZ with get() = scaleZ
                        and  set v = scaleZ <- v
                                     this.updateTransform()
    
    ///The rotation matrix, easily generated by the functions
    ///Matrix.rotationX, Matrix.rotationY, Matrix.rotationZ,
    ///Matrix.rotationEuler, Matrix.rotationAxis.
    ///The matrix doesn't have to be orthogonal.
    member this.RotationMatrix with get() = rotation
                               and  set v = rotation <- v
                                            this.updateTransform()
        
    member this.ColorSurface with get() = colorSurface
                             and  set v = colorSurface <- v
    
    member this.EmissiveSurface with get() = emissiveSurface
                                and  set v = emissiveSurface <- v
    
    member this.ReflectivitySurface with get() = reflectivitySurface
                                    and  set v = reflectivitySurface <- v
    
    member this.SpecularExponentSurface with get() = specExpSurface
                                        and  set v = specExpSurface <- v
    
    member this.SpecularitySurface with get() = specularitySurface
                                   and  set v = specularitySurface <- v
    
    member this.TranslucencySurface with get() = translucencySurface
                                    and  set v = translucencySurface <- v
    
    ///Beware that setting this transform does not update the properties
    ///Center, Rotation, ScaleX, ScaleY and ScaleZ and that setting any
    ///of them will generate a new Transform, replacing the one you set.
    member this.Transform with get() = transform
                          and  set v = transform <- v
                                       transformInverse <- Matrix.inverse v
    
    member this.TransformInverse = transformInverse
    
    abstract TextureMap : vector -> float * float
    
    member this.Color (position) = 
        transformInverse * position |> this.TextureMap |> colorSurface
    
    member this.Emissive (position) = 
        transformInverse * position |> this.TextureMap |> emissiveSurface    
    
    member this.Reflectivity (position) = 
        transformInverse * position |> this.TextureMap |> reflectivitySurface
    
    member this.SpecularExponent (position) = 
        transformInverse * position |> this.TextureMap |> specExpSurface
    
    member this.Specularity (position) =
        transformInverse * position |> this.TextureMap |> specularitySurface
    
    member this.Translucency (position) = 
        transformInverse * position |> this.TextureMap |> translucencySurface
    
    abstract Normal : vector -> vector
    
    abstract Intersect : Ray -> float option